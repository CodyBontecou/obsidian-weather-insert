/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WeatherInsertPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  location: "",
  units: "imperial",
  format: "{icon} {temp}, {conditions} | Wind: {wind}",
  apiProvider: "openmeteo",
  showWind: true,
  showHumidity: false
};
function wmoCodeToCondition(code) {
  var _a;
  const map = {
    0: { text: "Clear sky", icon: "\u2600\uFE0F" },
    1: { text: "Mainly clear", icon: "\u{1F324}" },
    2: { text: "Partly cloudy", icon: "\u26C5" },
    3: { text: "Overcast", icon: "\u2601\uFE0F" },
    45: { text: "Fog", icon: "\u{1F32B}" },
    48: { text: "Depositing rime fog", icon: "\u{1F32B}" },
    51: { text: "Light drizzle", icon: "\u{1F326}" },
    53: { text: "Moderate drizzle", icon: "\u{1F326}" },
    55: { text: "Dense drizzle", icon: "\u{1F327}" },
    56: { text: "Light freezing drizzle", icon: "\u{1F327}" },
    57: { text: "Dense freezing drizzle", icon: "\u{1F327}" },
    61: { text: "Slight rain", icon: "\u{1F326}" },
    63: { text: "Moderate rain", icon: "\u{1F327}" },
    65: { text: "Heavy rain", icon: "\u{1F327}" },
    66: { text: "Light freezing rain", icon: "\u{1F327}" },
    67: { text: "Heavy freezing rain", icon: "\u{1F327}" },
    71: { text: "Slight snow", icon: "\u{1F328}" },
    73: { text: "Moderate snow", icon: "\u{1F328}" },
    75: { text: "Heavy snow", icon: "\u2744\uFE0F" },
    77: { text: "Snow grains", icon: "\u2744\uFE0F" },
    80: { text: "Slight rain showers", icon: "\u{1F326}" },
    81: { text: "Moderate rain showers", icon: "\u{1F327}" },
    82: { text: "Violent rain showers", icon: "\u{1F327}" },
    85: { text: "Slight snow showers", icon: "\u{1F328}" },
    86: { text: "Heavy snow showers", icon: "\u2744\uFE0F" },
    95: { text: "Thunderstorm", icon: "\u26C8" },
    96: { text: "Thunderstorm with slight hail", icon: "\u26C8" },
    99: { text: "Thunderstorm with heavy hail", icon: "\u26C8" }
  };
  return (_a = map[code]) != null ? _a : { text: "Unknown", icon: "\u{1F321}" };
}
async function geocode(location) {
  const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(location)}&count=1&language=en&format=json`;
  const resp = await (0, import_obsidian.requestUrl)({ url });
  const data = resp.json;
  if (!data.results || data.results.length === 0) {
    throw new Error(`Location "${location}" not found. Try a city name like "New York" or "London".`);
  }
  const r = data.results[0];
  return {
    latitude: r.latitude,
    longitude: r.longitude,
    name: r.name,
    country: r.country,
    admin1: r.admin1
  };
}
async function fetchOpenMeteo(location, units) {
  const geo = await geocode(location);
  const tempUnit = units === "metric" ? "celsius" : "fahrenheit";
  const windUnit = units === "metric" ? "kmh" : "mph";
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${geo.latitude}&longitude=${geo.longitude}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m&temperature_unit=${tempUnit}&wind_speed_unit=${windUnit}&forecast_days=1`;
  const resp = await (0, import_obsidian.requestUrl)({ url });
  const data = resp.json;
  const current = data.current;
  const { text, icon } = wmoCodeToCondition(current.weather_code);
  const tempSymbol = units === "metric" ? "\xB0C" : "\xB0F";
  const windLabel = units === "metric" ? "km/h" : "mph";
  const locationLabel = geo.admin1 ? `${geo.name}, ${geo.admin1}` : `${geo.name}, ${geo.country}`;
  return {
    temp: `${Math.round(current.temperature_2m)}${tempSymbol}`,
    conditions: text,
    icon,
    wind: `${Math.round(current.wind_speed_10m)} ${windLabel}`,
    humidity: `${current.relative_humidity_2m}%`,
    feelsLike: `${Math.round(current.apparent_temperature)}${tempSymbol}`,
    location: locationLabel
  };
}
async function fetchWttr(location, units) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const unitParam = units === "metric" ? "m" : "u";
  const url = `https://wttr.in/${encodeURIComponent(location)}?format=j1&${unitParam}`;
  const resp = await (0, import_obsidian.requestUrl)({ url });
  const data = resp.json;
  const current = (_a = data.current_condition) == null ? void 0 : _a[0];
  if (!current) {
    throw new Error("Could not parse weather data from wttr.in");
  }
  const tempSymbol = units === "metric" ? "\xB0C" : "\xB0F";
  const temp = units === "metric" ? current.temp_C : current.temp_F;
  const feelsLike = units === "metric" ? current.FeelsLikeC : current.FeelsLikeF;
  const windSpeed = units === "metric" ? current.windspeedKmph : current.windspeedMiles;
  const windLabel = units === "metric" ? "km/h" : "mph";
  const conditions = (_d = (_c = (_b = current.weatherDesc) == null ? void 0 : _b[0]) == null ? void 0 : _c.value) != null ? _d : "Unknown";
  const icon = conditionTextToIcon(conditions);
  const nearestArea = (_e = data.nearest_area) == null ? void 0 : _e[0];
  const locName = (_h = (_g = (_f = nearestArea == null ? void 0 : nearestArea.areaName) == null ? void 0 : _f[0]) == null ? void 0 : _g.value) != null ? _h : location;
  const locRegion = (_k = (_j = (_i = nearestArea == null ? void 0 : nearestArea.region) == null ? void 0 : _i[0]) == null ? void 0 : _j.value) != null ? _k : "";
  return {
    temp: `${temp}${tempSymbol}`,
    conditions,
    icon,
    wind: `${windSpeed} ${windLabel}`,
    humidity: `${current.humidity}%`,
    feelsLike: `${feelsLike}${tempSymbol}`,
    location: locRegion ? `${locName}, ${locRegion}` : locName
  };
}
function conditionTextToIcon(text) {
  const lower = text.toLowerCase();
  if (lower.includes("thunder"))
    return "\u26C8";
  if (lower.includes("snow") || lower.includes("blizzard"))
    return "\u2744\uFE0F";
  if (lower.includes("sleet") || lower.includes("freezing"))
    return "\u{1F328}";
  if (lower.includes("heavy rain") || lower.includes("downpour"))
    return "\u{1F327}";
  if (lower.includes("rain") || lower.includes("drizzle"))
    return "\u{1F326}";
  if (lower.includes("fog") || lower.includes("mist"))
    return "\u{1F32B}";
  if (lower.includes("overcast"))
    return "\u2601\uFE0F";
  if (lower.includes("partly") || lower.includes("cloudy"))
    return "\u26C5";
  if (lower.includes("clear") || lower.includes("sunny"))
    return "\u2600\uFE0F";
  return "\u{1F321}";
}
function formatWeather(weather, format, settings) {
  let result = format.replace(/{icon}/g, weather.icon).replace(/{temp}/g, weather.temp).replace(/{conditions}/g, weather.conditions).replace(/{wind}/g, weather.wind).replace(/{humidity}/g, weather.humidity).replace(/{feelsLike}/g, weather.feelsLike).replace(/{location}/g, weather.location);
  if (!settings.showWind) {
    result = result.replace(/\s*\|\s*Wind:\s*\S+\s*\S*/g, "");
  }
  if (!settings.showHumidity) {
    result = result.replace(/\s*\|\s*Humidity:\s*\S+/g, "");
  }
  return result.trim();
}
var WeatherInsertPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "insert-weather",
      name: "Insert current weather",
      editorCallback: async (editor, view) => {
        await this.insertWeather(editor);
      }
    });
    this.addCommand({
      id: "insert-weather-frontmatter",
      name: "Insert weather into frontmatter",
      editorCallback: async (editor, view) => {
        await this.insertWeatherFrontmatter(editor);
      }
    });
    this.addSettingTab(new WeatherInsertSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async fetchWeather() {
    const loc = this.settings.location;
    if (!loc) {
      throw new Error(
        "No location set. Open Settings \u2192 Weather Insert to configure your location."
      );
    }
    if (this.settings.apiProvider === "wttr") {
      return fetchWttr(loc, this.settings.units);
    }
    return fetchOpenMeteo(loc, this.settings.units);
  }
  async insertWeather(editor) {
    new import_obsidian.Notice("Fetching weather\u2026");
    try {
      const weather = await this.fetchWeather();
      const line = formatWeather(
        weather,
        this.settings.format,
        this.settings
      );
      const cursor = editor.getCursor();
      editor.replaceRange(line, cursor);
      editor.setCursor({
        line: cursor.line,
        ch: cursor.ch + line.length
      });
      new import_obsidian.Notice("Weather inserted \u2713");
    } catch (e) {
      new import_obsidian.Notice(`Weather error: ${e.message}`);
      console.error("Weather Insert:", e);
    }
  }
  async insertWeatherFrontmatter(editor) {
    new import_obsidian.Notice("Fetching weather\u2026");
    try {
      const weather = await this.fetchWeather();
      const content = editor.getValue();
      const fmFields = [
        `weather_temp: "${weather.temp}"`,
        `weather_conditions: "${weather.conditions}"`,
        `weather_icon: "${weather.icon}"`,
        `weather_wind: "${weather.wind}"`,
        `weather_humidity: "${weather.humidity}"`,
        `weather_location: "${weather.location}"`
      ].join("\n");
      if (content.startsWith("---")) {
        const closingIdx = content.indexOf("---", 3);
        if (closingIdx !== -1) {
          const before = content.slice(0, closingIdx);
          const after = content.slice(closingIdx);
          editor.setValue(before + fmFields + "\n" + after);
        }
      } else {
        editor.setValue(
          "---\n" + fmFields + "\n---\n\n" + content
        );
      }
      new import_obsidian.Notice("Weather added to frontmatter \u2713");
    } catch (e) {
      new import_obsidian.Notice(`Weather error: ${e.message}`);
      console.error("Weather Insert:", e);
    }
  }
};
var WeatherInsertSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Weather Insert" });
    new import_obsidian.Setting(containerEl).setName("Location").setDesc(
      'City name (e.g. "New York", "London", "Tokyo"). Used for geocoding.'
    ).addText(
      (text) => text.setPlaceholder("New York").setValue(this.plugin.settings.location).onChange(async (value) => {
        this.plugin.settings.location = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Units").setDesc("Temperature and wind speed units.").addDropdown(
      (dropdown) => dropdown.addOption("imperial", "Imperial (\xB0F, mph)").addOption("metric", "Metric (\xB0C, km/h)").setValue(this.plugin.settings.units).onChange(async (value) => {
        this.plugin.settings.units = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Weather source").setDesc(
      "Open-Meteo is more reliable. wttr.in is a fallback option."
    ).addDropdown(
      (dropdown) => dropdown.addOption("openmeteo", "Open-Meteo (recommended)").addOption("wttr", "wttr.in").setValue(this.plugin.settings.apiProvider).onChange(async (value) => {
        this.plugin.settings.apiProvider = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Format template").setDesc(
      "Available tokens: {icon} {temp} {conditions} {wind} {humidity} {feelsLike} {location}"
    ).addTextArea(
      (text) => text.setPlaceholder(
        "{icon} {temp}, {conditions} | Wind: {wind}"
      ).setValue(this.plugin.settings.format).onChange(async (value) => {
        this.plugin.settings.format = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show wind").setDesc("Include wind speed in the default format.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showWind).onChange(async (value) => {
        this.plugin.settings.showWind = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show humidity").setDesc("Include humidity percentage in the default format.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showHumidity).onChange(async (value) => {
        this.plugin.settings.showHumidity = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Preview" });
    const previewEl = containerEl.createEl("div", {
      cls: "weather-insert-preview"
    });
    previewEl.style.padding = "12px";
    previewEl.style.background = "var(--background-secondary)";
    previewEl.style.borderRadius = "6px";
    previewEl.style.fontFamily = "var(--font-monospace)";
    previewEl.style.marginBottom = "12px";
    const previewBtn = containerEl.createEl("button", {
      text: "Fetch preview"
    });
    previewBtn.addEventListener("click", async () => {
      previewEl.setText("Fetching\u2026");
      try {
        const weather = this.plugin.settings.apiProvider === "wttr" ? await fetchWttr(
          this.plugin.settings.location,
          this.plugin.settings.units
        ) : await fetchOpenMeteo(
          this.plugin.settings.location,
          this.plugin.settings.units
        );
        const line = formatWeather(
          weather,
          this.plugin.settings.format,
          this.plugin.settings
        );
        previewEl.setText(line);
      } catch (e) {
        previewEl.setText(`Error: ${e.message}`);
      }
    });
  }
};
